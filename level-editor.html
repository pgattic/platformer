<!DOCTYPE html>
<html>
	<head>
		<style>
			body {user-select: none;}
			#main {
				margin: auto;
				position: absolute;
				top: 50%;
				left: 50%;
				-ms-transform: translate(-50%, -50%);
				transform: translate(-50%, -50%);
				
			}
			canvas {
				background: #ccc;
				transition:.25s;
				cursor: crosshair;
			}
			#pause {
				background: #aaa;
				margin: 0;
				padding: 10px;
				font: 36px Arial;
				position: absolute;
				top: 50%;
				left: 50%;
				-ms-transform: translate(-50%, -50%);
				transform: translate(-50%, -50%);
				display: none;
				place-items: center;
				border: 1px solid black;
				border-radius: 5px;
			}
			#pause button {
				background-color: #777;
				border: 1px solid black;
				margin: 1px;
				border-radius: 5px;
			}
			p {
				position: absolute;
				font-family: Courier;
				margin: 0;
				padding:5px;
				background: white;
			}
			
		</style>
	</head>
	<body>
		<div id="main">
			<canvas id="platformer">Your browser doesn't support the HTML5 canvas element!</canvas>
			<div id="pause">
				PAUSED<br>
				<button onclick="togglePause()">Resume</button>
				<button onclick="togglePause();init()">Restart Level</button>
				<button onclick="togglePause();level=startLevel;init()">Clear Progress</button>
			</div>
		</div>
		Press Esc to toggle between editing and testing!
		<form>
			Tool:
			<select id="tools" name="tools">
				<option value="start">Start (click)</option>
				<option value="end">End (click)</option>
				<option value="plat">Platforms (drag)</option>
				<option value="lava">Lava (drag)</option>
				<option value="keys">Keys (click)</option>
				<option value="port">Portals (drag)</option>
			</select>
		</form>
		Level text tips (optional):<br><input type="text"id="text"oninput="levels[level].text=this.value;editDraw()"></input><br>
		Mouse position: <span id="cursor"></span><br>
		Lock to the nearest <input type="number"oninput="locker=this.value;editDraw()"value="25"></input><br>
		Shift + Click = Delete. <br>When deleting, click near:<ul><li>top-left corner of rectangular objects</li><li>center of circular objects</li></ul>
		<span id="version"></span><br>
		<button id="download" title="Ctrl + S">Download level</button><a id="a" style="display:none"></a><br>
		<input type="file" id="upload" style="display:none"><button onclick="upload.click()">Upload Level</button>

		<script>var levels=[{
		version: 1,
		start: [],
		end: [],
		boxes: [],
		text: "",
		lava: [],
		keys: [],
		portals: []
		}],startLevel=0,editing=true;</script>
		<script src="engine.js"></script>
		<script>
			clearInterval(interval);
			
			document.getElementById("version").innerText = "Engine: " + version +"\n Editor: v1.0.0";
			
			const
				tools = document.getElementById("tools"),
				deleteRadius = 30,
				mousePos = document.getElementById("cursor");
				download = $("#download"),
				upload = $("#upload");

			var
				mouse = {
					downX : NaN,
					downY : NaN,
					x : NaN,
					y : NaN,
				},
				editing = true,
				locker = 25;
			
			canvas.addEventListener("mousedown", mouseDownHandler, false);
			canvas.addEventListener("mousemove", mouseMoveHandler, false);
//			canvas.addEventListener("mouseleave", mouseUpHandler, false);
			canvas.addEventListener("mouseup", mouseUpHandler, false);

			download.onclick = () => {
				var a = document.getElementById("a");
				var output=JSON.stringify(levels[level]);
				a.href = URL.createObjectURL(new Blob([output], {type: "text/json"}));
				a.download = "level.json";
				a.click();
			}


			function readFileContent(file) {
				const reader = new FileReader();
				return new Promise((resolve, reject) => {
					reader.onload = event => resolve(event.target.result);
					reader.onerror = error => reject(error);
					reader.readAsText(file);
				});
			}

			function placeFileContent(target, file) {
				readFileContent(file).then(content => {
					levels[0] = JSON.parse(content);
				}).catch(error => console.log(error))
			}

			upload.onchange = () => {
				const input = event.target
				if ('files' in input && input.files.length > 0) {
					placeFileContent(levels[0], input.files[0]);
				}
			}


			function lockReplace(x) {
				return Math.round(x / locker) * locker;
			}
			
			function mouseDownHandler(e) {
				switch (tools.value) {
					case "start":
						if (e.shiftKey) {
							var dist = Math.sqrt((levels[level].start[0] - lockReplace(e.offsetX)) ** 2 + (levels[level].start[1] - lockReplace(e.offsetY)) ** 2);
							if (dist < deleteRadius) {
								levels[level].start[0] = NaN;
								levels[level].start[1] = NaN;
							}
						} else if (levels[level].start) {
							levels[level].start[0] = lockReplace(e.offsetX);
							levels[level].start[1] = lockReplace(e.offsetY);
						}
						break;
					case "end":
						if (e.shiftKey) {
							var dist = Math.sqrt((levels[level].end[0] - lockReplace(e.offsetX)) ** 2 + (levels[level].end[1] - lockReplace(e.offsetY)) ** 2);
							if (dist < deleteRadius) {
								levels[level].end[0] = NaN;
								levels[level].end[1] = NaN;
							}
						} else if (levels[level].end) {
							levels[level].end[0] = lockReplace(e.offsetX);
							levels[level].end[1] = lockReplace(e.offsetY);
						}
						break;
					case "plat":
						if (e.shiftKey) {
							var closestBox = [];
							for (var i = 0; i < levels[level].boxes.length; i++) {
								var dist = Math.sqrt((levels[level].boxes[i][0] - lockReplace(e.offsetX)) ** 2 + (levels[level].boxes[i][1] - lockReplace(e.offsetY)) ** 2);
								if (dist < deleteRadius && (dist < closestBox[1] || i == 0)) {
									closestBox = [i, dist];
								}
							}
							if (closestBox.length == 2) {levels[level].boxes.splice(closestBox[0], 1);}
						} else if (levels[level].boxes) {
							levels[level].boxes.unshift([lockReplace(e.offsetX), lockReplace(e.offsetY), 0]);
						}
						break;
					case "lava":
						if (e.shiftKey) {
							var closestLava = [];
							for (var i = 0; i < levels[level].lava.length; i++) {
								var dist = Math.sqrt((levels[level].lava[i][0] - lockReplace(e.offsetX)) ** 2 + (levels[level].lava[i][1] - lockReplace(e.offsetY)) ** 2);
								if (dist < deleteRadius && (dist < closestLava[1] || i == 0)) {
									closestLava = [i, dist];
								}
							}
							if (closestLava.length == 2) {levels[level].lava.splice(closestLava[0], 1);}
						} else if (levels[level].lava) {
							levels[level].lava.unshift([lockReplace(e.offsetX), lockReplace(e.offsetY), 0, 0]);
						}
						break;
					case "keys":
						if (e.shiftKey) {
							var closestKey = [];
							for (var i = 0; i < levels[level].keys.length; i++) {
								var dist = Math.sqrt((levels[level].keys[i][0] - lockReplace(e.offsetX)) ** 2 + (levels[level].keys[i][1] - lockReplace(e.offsetY)) ** 2);
								if (dist < deleteRadius && (dist < closestKey[1] || i == 0)) {
									closestKey = [i, dist];
								}
							}
							if (closestKey.length == 2) {levels[level].keys.splice(closestKey[0], 1);}
						} else if (levels[level].keys) {
							levels[level].keys.unshift([lockReplace(e.offsetX), lockReplace(e.offsetY)]);
						}
						break;
					case "port":
						if (e.shiftKey) {
							var closestPort = [];
							for (var i = 0; i < levels[level].portals.length; i++) {
								var dist = Math.sqrt((levels[level].portals[i][0][0] - lockReplace(e.offsetX)) ** 2 + (levels[level].portals[i][0][1] - lockReplace(e.offsetY)) ** 2);
								if (dist < deleteRadius && (dist < closestPort[1] || i == 0)) {
									closestPort = [i, dist];
								}
								var dista = Math.sqrt((levels[level].portals[i][1][0] - lockReplace(e.offsetX)) ** 2 + (levels[level].portals[i][1][1] - lockReplace(e.offsetY)) ** 2);
								if (dista < deleteRadius && (dista < closestPort[1] || i == 0)) {
									closestPort = [i, dista];
								}
							}
							if (closestPort.length == 2) {levels[level].portals.splice(closestPort[0], 1);}
						} else if (levels[level].portals) {
							levels[level].portals.unshift([[lockReplace(e.offsetX), lockReplace(e.offsetY)], [lockReplace(e.offsetX), lockReplace(e.offsetY)]]);
						}
						break;
				}
				editDraw();
			}
			
			function mouseMoveHandler(e) {
				if (e.buttons == 1 && !e.shiftKey) {
					switch (tools.value) {
						case "plat":
							if (levels[level].boxes.length > 0) levels[level].boxes[0][2] = lockReplace(e.offsetX) - levels[level].boxes[0][0];
							break;
						case "lava":
							if (levels[level].lava.length > 0) {
								levels[level].lava[0][2] = lockReplace(e.offsetX) - levels[level].lava[0][0];
								levels[level].lava[0][3] = lockReplace(e.offsetY) - levels[level].lava[0][1];
							}
							break;
						case "port":
							if (levels[level].portals.length > 0) {
								levels[level].portals[0][1][0] = lockReplace(e.offsetX);
								levels[level].portals[0][1][1] = lockReplace(e.offsetY);
							}
							break;
					}
				}
				mousePos.innerText = lockReplace(e.offsetX) + ", " + lockReplace(e.offsetY);
				if (editing) editDraw();
			}
			
			function mouseUpHandler(e) {
				if (!e.shiftKey) {
					switch (tools.value) {
						case "plat":
							levels[level].boxes[0][2] = lockReplace(e.offsetX) - levels[level].boxes[0][0];
							if (levels[level].boxes[0][2] < 0) {
								levels[level].boxes[0][0] += levels[level].boxes[0][2];
								levels[level].boxes[0][2] = -levels[level].boxes[0][2]
							}
							if (levels[level].boxes[0][2] == 0) {
								levels[level].boxes.shift();
							}
							break;
						case "lava":
							levels[level].lava[0][2] = lockReplace(e.offsetX) - levels[level].lava[0][0];
							levels[level].lava[0][3] = lockReplace(e.offsetY) - levels[level].lava[0][1];
							if (levels[level].lava[0][2] < 0) {
								levels[level].lava[0][0] += levels[level].lava[0][2];
								levels[level].lava[0][2] = -levels[level].lava[0][2]
							}
							if (levels[level].lava[0][3] < 0) {
								levels[level].lava[0][1] += levels[level].lava[0][3];
								levels[level].lava[0][3] = -levels[level].lava[0][3]
							}
							if (levels[level].lava[0][2] == 0 || levels[level].lava[0][3] == 0) {
								levels[level].lava.shift();
							}
							break;
						case "port":
							levels[level].portals[0][1][0] = lockReplace(e.offsetX);
							levels[level].portals[0][1][1] = lockReplace(e.offsetY);
							break;
					}
					editDraw();
				}
			}

function editDrawGrid() {
	if (locker >= 5) {
		ctx.lineWidth = 0.5;
		ctx.strokeStyle = "#000";
		for (var i = 0; i < canvas.width / locker; i++) {
			ctx.beginPath();
			ctx.moveTo(i * locker, 0);
			ctx.lineTo(i * locker, canvas.height);
			ctx.stroke();
			ctx.closePath();
		}
		for (var i = 0; i < canvas.height / locker; i++) {
			ctx.beginPath();
			ctx.moveTo(0, i * locker);
			ctx.lineTo(canvas.width, i * locker);
			ctx.stroke();
			ctx.closePath();
		}
	}
}

function editDrawGoal() { // draws the green goal semicircle
	if (levels[level].end) {
		ctx.beginPath();
		ctx.strokeStyle = "green";
		ctx.arc(levels[level].end[0], levels[level].end[1], goalRadius, 0, Math.PI * 2);
		ctx.lineWidth = goalThickness;
		ctx.stroke();
		ctx.closePath();
	}
}

function editDrawKeys() { // Draws the blue circular keys.
	if (levels[level].keys) {
		for (var i = 0; i < levels[level].keys.length; i++) {
			ctx.beginPath();
			ctx.arc(levels[level].keys[i][0], levels[level].keys[i][1], goalRadius, 0, Math.PI*2);
			ctx.fillStyle = "yellow"
			ctx.fill();
			ctx.closePath();
		}
	}
}

function editDrawSprite(obj) {
	ctx.beginPath();
	ctx.rect(levels[level].start[0], levels[level].start[1], obj.size[obj.stage], obj.size[obj.stage]);
	ctx.rect(levels[level].start[0], levels[level].start[1] - canvas.height, obj.size[obj.stage], obj.size[obj.stage]);
	ctx.fillStyle = obj.color;
	ctx.fill();
	ctx.closePath();
}

function editDrawHint() {
	ctx.beginPath();
	ctx.fillStyle = "black";
	ctx.font = "15px Courier";
	if (levels[level].text) {
		ctx.fillText("> L" + level + ": " + levels[level].text + "_", 75, 75);
	}
	else {
		ctx.fillText("> L" + level, 75, 75);
	}
	ctx.closePath();
}

function editDraw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height)
	if (editing) editDrawGrid();
	drawBlocks();
	editDrawGoal();
	editDrawKeys();
	drawPortals();
	editDrawSprite(player);
	drawLava();
	editDrawHint();
}

editDraw();

function togglePause() {
	editing = !editing;
	if (editing) {
		clearInterval(interval);
		editDraw();
	}
	else {
		interval = setInterval(main, 12);
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		init();
	}
}

function finishLevel() { // Checks if the player has gotten to the end of the level
	if (levels[level].end) {
		allKeys = true;
		for (var i of keysCollected) { // have all the keys been collected?
			if (i == false) {allKeys = false}
		}
//		console.log(allKeys);
		if (allKeys) {
			var x = player.x + player.size[player.stage] / 2 - levels[level].end[0];
			var y = player.y + player.size[player.stage] / 2 - levels[level].end[1];
			if (Math.sqrt(x ** 2 + y ** 2) < player.size[player.stage] / 2 + goalRadius) {
				init();
			}
		}
	}
}


			//var editInterval = setInterval(editMain, 12);
		</script>
	</body>
</html>
